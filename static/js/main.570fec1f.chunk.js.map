{"version":3,"sources":["Controls.js","App.js","reportWebVitals.js","index.js"],"names":["Marvin","window","MarvinImage","aspect_ratios","twitch","youtube","custom","symbol","FilePicker","props","settings","setSettings","htmlFor","id","type","accept","onChange","e","files","target","length","path","Settings","setRawData","useState","img","setImg","imgRef","useRef","onLoad","useCallback","current","previewCanvasRef","crop","setCrop","useEffect","aspect","completedCrop","setCompletedCrop","Object","keys","setType","cutDownSide","side","to","parseInt","configured","width","height","image","canvas","scaleX","naturalWidth","scaleY","naturalHeight","ctx","getContext","pixelRatio","devicePixelRatio","setTransform","imageSmoothingQuality","drawImage","x","y","cropImage","tempIn","tempOut","canvasData","toDataURL","load","clone","grayScale","detectEdges","prewitt","invertColors","thresholding","Math","floor","threshold","draw","result","scale","imageData","reader","FileReader","addEventListener","readAsDataURL","onTypeChange","value","variants","push","name","defaultChecked","className","min","max","defaultValue","onThresholdChange","checked","onEdgeChange","onInvertChange","src","onImageLoaded","c","onComplete","onDragEnd","Preview","ref","Result","rawData","at","index","data","getSymbolAt","i","j","code","String","fromCharCode","rows","line","Controls","values","Header","Footer","year","Date","getFullYear","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.570fec1f.chunk.js","sourcesContent":["import \"./Controls.css\";\nimport \"react-image-crop/dist/ReactCrop.css\";\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport ReactCrop from \"react-image-crop\";\n\nconst Marvin = window.Marvin;\nconst MarvinImage = window.MarvinImage;\n\nconst aspect_ratios = {\n  // 30 characters wide, 500 characters total\n  // keeping in mind that a Braille pattern symbol is 2x4 dots,\n  // that would result in an image of 60x64 pixels\n  twitch: [60, 64],\n  // same width, but only 200 characters\n  youtube: [60, 24],\n  custom: [],\n};\n\nconst symbol = {\n  width: 2,\n  height: 4,\n};\n\nconst FilePicker = (props) => {\n  const { settings, setSettings } = props;\n\n  const onChange = (e) => {\n    const files = e.target.files;\n    if (files.length !== 0) {\n      setSettings({ ...settings, path: files[0] });\n    }\n  };\n\n  return (\n    <div>\n      <label htmlFor=\"file\">Picture file: </label>\n      <input\n        id=\"file\"\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={(e) => onChange(e)}\n      />\n    </div>\n  );\n};\n\nconst Settings = (props) => {\n  const { settings, setSettings } = props;\n  const { setRawData } = props;\n  const [img, setImg] = useState(null);\n  // since I only want to track the changes of settings\n  // I use refs in order to preserve images across lifecycles\n  const imgRef = useRef(null);\n  const onLoad = useCallback((img) => {\n    imgRef.current = img;\n  }, []);\n  const previewCanvasRef = settings.previewCanvasRef;\n  const [crop, setCrop] = useState({});\n  useEffect(() => {\n    setCrop({ aspect: settings.aspect });\n  }, [settings.aspect]);\n\n  const [completedCrop, setCompletedCrop] = useState(null);\n  const onCropCompleted = () => {\n    if (!settings.configured) {\n      setSettings({ ...settings, configured: true });\n    }\n  };\n  const [type, setType] = useState(Object.keys(aspect_ratios)[0]);\n\n  const cropImage = (image, canvas, crop) => {\n    const scaleX = image.naturalWidth / image.width;\n    const scaleY = image.naturalHeight / image.height;\n    const ctx = canvas.getContext(\"2d\");\n    const pixelRatio = window.devicePixelRatio;\n\n    canvas.width = crop.width * pixelRatio;\n    canvas.height = crop.height * pixelRatio;\n\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    ctx.imageSmoothingQuality = \"high\";\n\n    ctx.drawImage(\n      image,\n      crop.x * scaleX,\n      crop.y * scaleY,\n      crop.width * scaleX,\n      crop.height * scaleY,\n      0,\n      0,\n      crop.width,\n      crop.height\n    );\n  };\n\n  const convertedThreshold = () => {\n    return Math.floor(settings.threshold * 2.55);\n  };\n\n  const cutDownSide = (side, to) => {\n    return parseInt(side - (side % to));\n  };\n\n  // here's the main entry point where all image processing happens\n  useEffect(() => {\n    if (\n      !completedCrop ||\n      !previewCanvasRef.current ||\n      !imgRef.current ||\n      !settings.configured ||\n      completedCrop.width < symbol.width ||\n      completedCrop.height < symbol.height\n    ) {\n      return;\n    }\n    const image = imgRef.current;\n    const canvas = previewCanvasRef.current;\n    const crop = completedCrop;\n    if (!crop.width || !crop.height) {\n      // the crop is effectively empty, nothing to process\n      return;\n    }\n    cropImage(image, canvas, crop);\n    let tempIn = new MarvinImage();\n    let tempOut = new MarvinImage();\n\n    const canvasData = canvas.toDataURL();\n    tempIn.load(canvasData, () => {\n      // this whole part is kinda ugly I admit it, but it takes time to sort\n      // things out and write it neatly when there's no api docs at all, so I'm\n      // not investing that time nether into this library in particular nor into\n      // this project in whole.\n      tempOut = tempIn.clone();\n      Marvin.grayScale(tempIn, tempOut);\n      if (settings.detectEdges) {\n        tempIn = tempOut.clone();\n        Marvin.prewitt(tempIn, tempOut);\n      }\n      if (settings.invertColors) {\n        tempIn = tempOut.clone();\n        Marvin.invertColors(tempIn, tempOut);\n      }\n      tempIn = tempOut.clone();\n      Marvin.thresholding(tempIn, tempOut, convertedThreshold());\n      tempOut.draw(canvas);\n      let width, height;\n      if (type === \"custom\") {\n        // because Braille patter symbols are of size 2x4,\n        // width and height should be an integer multiply of\n        // 2 and 4 respectively\n        width = cutDownSide(completedCrop.width, symbol.width);\n        height = cutDownSide(completedCrop.height, symbol.height);\n      } else {\n        width = aspect_ratios[type][0];\n        height = aspect_ratios[type][1];\n      }\n      let result = new MarvinImage();\n      Marvin.scale(tempOut, result, width, height);\n      setRawData(result.imageData);\n    });\n    // eslint-disable-next-line\n  }, [completedCrop, previewCanvasRef, settings]);\n\n  useEffect(() => {\n    if (settings.path) {\n      let reader = new FileReader();\n      reader.addEventListener(\"load\", () => setImg(reader.result));\n      reader.readAsDataURL(settings.path);\n    }\n  }, [settings.path]);\n\n  if (!settings.path) {\n    return null;\n  }\n\n  const onTypeChange = (e) => {\n    const type = e.target.value;\n    setType(type);\n    const value = aspect_ratios[type];\n    const aspect = value.length !== 0 ? value[0] / value[1] : null;\n    setSettings({ ...settings, aspect, configured: !settings.configured });\n    // in order to prevent rendering the same\n    // crop twice on preset change event\n    setCompletedCrop({});\n  };\n\n  const onThresholdChange = (e) => {\n    const value = parseInt(e.target.value);\n    setSettings({ ...settings, threshold: value });\n  };\n\n  const onEdgeChange = (e) => {\n    const detectEdges = e.target.checked;\n    setSettings({ ...settings, detectEdges });\n  };\n\n  const onInvertChange = (e) => {\n    const invertColors = e.target.checked;\n    setSettings({ ...settings, invertColors });\n  };\n\n  // doing it in an explicit way in order to be able to add other\n  // presets just by extending `aspect_ratios` object\n  const variants = [];\n  for (let type in aspect_ratios) {\n    variants.push(\n      <label key={`${type}_label`} htmlFor={type}>\n        <input\n          id={type}\n          type=\"radio\"\n          value={type}\n          name=\"type\"\n          defaultChecked={type === Object.keys(aspect_ratios)[0]}\n          onChange={(e) => onTypeChange(e)}\n        />{\" \"}\n        {type} <br />\n      </label>\n    );\n  }\n\n  return (\n    <>\n      <div className=\"settings\">\n        <form id=\"settings\">\n          <fieldset id=\"settings-fieldset\">\n            <legend>Settings</legend>\n            {variants}\n            <br />\n            <label htmlFor=\"threshold\">Threshold [1-99]: </label>\n            <input\n              key=\"threshold\"\n              id=\"threshold\"\n              type=\"range\"\n              name=\"threshold\"\n              min=\"1\"\n              max=\"99\"\n              defaultValue={settings.threshold}\n              onChange={(e) => onThresholdChange(e)}\n            />\n            <br />\n            <label htmlFor=\"edge\">\n              <input\n                key=\"edge\"\n                id=\"edge\"\n                type=\"checkbox\"\n                name=\"edge\"\n                defaultValue={settings.detectEdges}\n                onChange={(e) => onEdgeChange(e)}\n              />\n              Detect edges\n            </label>\n            <br />\n            <label htmlFor=\"invert\">\n              <input\n                key=\"invert\"\n                id=\"invert\"\n                type=\"checkbox\"\n                name=\"invert\"\n                defaultValue={settings.invertColors}\n                onChange={(e) => onInvertChange(e)}\n              />\n              Dark Mode\n            </label>\n          </fieldset>\n        </form>\n      </div>\n      <div className=\"crop\">\n        <p>Select an area to be rendered using your mouse:</p>\n        <ReactCrop\n          src={img}\n          crop={crop}\n          onImageLoaded={onLoad}\n          onChange={(c) => setCrop(c)}\n          onComplete={(c) => setCompletedCrop(c)}\n          onDragEnd={() => onCropCompleted()}\n        />\n      </div>\n    </>\n  );\n};\n\nconst Preview = (props) => {\n  const settings = props.settings;\n  if (!settings.configured) {\n    return null;\n  }\n  return (\n    <div className=\"preview\">\n      <p>Preview</p>\n      <canvas ref={settings.previewCanvasRef} />\n    </div>\n  );\n};\n\nconst Result = (props) => {\n  const rawData = props.rawData;\n  if (!rawData) {\n    return null;\n  }\n\n  const width = rawData.width;\n  const height = rawData.height;\n\n  const at = (x, y) => {\n    const index = y * (width * 4) + x * 4;\n    const pixel = rawData.data[index];\n    return pixel ? 0 : 1;\n  };\n\n  const getSymbolAt = (i, j) => {\n    const code =\n      at(i, j) * 1 +\n      at(i, j + 1) * 2 +\n      at(i, j + 2) * 4 +\n      at(i + 1, j) * 8 +\n      at(i + 1, j + 1) * 16 +\n      at(i + 1, j + 2) * 32 +\n      at(i, j + 3) * 64 +\n      at(i + 1, j + 3) * 128 +\n      0x2800;\n    return String.fromCharCode(code);\n  };\n\n  let rows = [];\n  for (let y = 0; y <= height - 1; y += symbol.height) {\n    let line = \"\";\n    for (let x = 0; x <= width - 1; x += symbol.width) {\n      line += getSymbolAt(x, y);\n    }\n    rows.push(\n      <pre key={y}>\n        {line}\n        <br />\n      </pre>\n    );\n  }\n\n  return (\n    <>\n      <p>\n        {\" \"}\n        Make sure to start selection from the very first character right after\n        this string, even if it seems to be \"empty\"{\" \"}\n      </p>\n      <div className=\"result\">\n        <pre>{rows}</pre>\n      </div>\n      <br />\n    </>\n  );\n};\n\nconst Controls = () => {\n  let aspect = Object.values(aspect_ratios)[0];\n  aspect = aspect[0] / aspect[1];\n  const previewCanvasRef = useRef(null);\n  // global state object that gets propagated everywhere\n  const [settings, setSettings] = useState({\n    path: null,\n    aspect,\n    threshold: 50,\n    detectEdges: false,\n    invertColors: false,\n    previewCanvasRef,\n    configured: false,\n  });\n\n  const [rawData, setRawData] = useState(null);\n\n  return (\n    <div className=\"Controls\">\n      <FilePicker settings={settings} setSettings={setSettings} />\n      <Settings\n        settings={settings}\n        setSettings={setSettings}\n        setRawData={setRawData}\n      />\n      <Preview settings={settings} />\n      <Result rawData={rawData} />\n    </div>\n  );\n};\n\nexport { Controls };\n","import \"./App.css\";\nimport { Controls } from \"./Controls\";\n\nconst Header = () => {\n  return (\n    <header>\n      <h3>Generate ASCII Art from a picture using Braille patterns</h3>\n    </header>\n  );\n};\n\nconst Footer = () => {\n  const year = new Date().getFullYear();\n  return (\n    <footer>\n      <hr />\n      &copy; Copyright {year} <strong>Not a Designer </strong>LLC.\n    </footer>\n  );\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Controls></Controls>\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}